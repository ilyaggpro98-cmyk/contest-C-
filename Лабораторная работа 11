#include <bits/stdc++.h>
using namespace std;

double f(double x)
{
    return -0.3 * pow(x,5) + 2.3 * x + 7.5;
}

const double INF = 1e9;

void Solve()
{
    const double coef_num = 2.3;
    const double coef_den = 1.5;
    double base = coef_num / coef_den;
    if (base < 0.0) {
        cout << "Нет вещественных корней для производной\n";
        return;
    }

    double r = pow(base, 1.0 / 4.0);
    double x1 = -r;
    double x2 = r;
    if (x1 > x2) swap(x1, x2);

    cout.setf(std::ios::fixed);
    cout << setprecision(5);
    cout << "Корни производной f'(x)=0: x1 = " << x1 << " , x2 = " << x2 << '\n';
    cout << "Значения функции в этих точках: f(x1) = " << f(x1) << " , f(x2) = " << f(x2) << "\n\n";

    const double eps = 0.005;
    const double maxStep = 1.0;
    const double scanM = 10.0;

    vector<pair<double,double>> res;
    cout << "Выведите значения a,b:\n";
    double a,b;
    cin >> a >> b;

    res.push_back({a,b});



    for (auto [Lreg, Rreg] : res)
    {
        double L = Lreg;
        double R = Rreg;

        swap(L,R); // этот случай не нужен
        double fL = f(L);
        double fR = f(R);

        if (!(fL < 0.0 && fR > 0.0)) continue;

        double left = L;
        double right = R;
        double fl = fL;
        double fr = fR;

        int iter_limit = 0;
        while (right - left > maxStep && iter_limit < 200)
        {
            double mid = (left + right) / 2.0;
            double fm = f(mid);

            if (fl < 0.0 && fm > 0.0)
            {
                right = mid;
                fr = fm;
            }
            else if (fm < 0.0 && fr > 0.0)
            {
                left = mid;
                fl = fm;
            }
            else
            {
                if (fabs(fm) < 1e-15)
                {
                    left = mid;
                    right = mid;
                    fl = fr = fm;
                    break;
                }
                double lmid = (left + mid) / 2.0;
                double rmid = (mid + right) / 2.0;
                double flmid = f(lmid);
                double frmid = f(rmid);

                if (fl < 0.0 && flmid > 0.0) { right = lmid; fr = flmid; }
                else if (flmid < 0.0 && fr > 0.0) { left = lmid; fl = flmid; }
                else if (fm < 0.0 && frmid > 0.0) { right = rmid; fr = frmid; }
                else if (fl < 0.0 && frmid > 0.0) { left = rmid; fl = frmid; }
                else break;
            }
            ++iter_limit;
        }


        double A = left;
        double B = right;
        cout << "Найден интервал A = " << A << " , B = " << B << "\n";
        cout << "f(A) = " << fl << " , f(B) = " << fr << "\n\n";
        int step = 1;
        while (true)
        {
            double xm = (A + B) / 2.0;
            double fxm = f(xm);
            if (fxm == 0.0)
            {
                cout << "Корень == " << xm << '\n';
                return;
            }
            cout << "x" << step << " = " << xm << "   f(x" << step << ") = " << fxm << "\n";
            if (fxm < 0.0) A = xm; else B = xm;
            ++step;
            if (step > 100) break;
        }

        double root = (A + B) / 2.0;
        cout << "\nПриближение корня с точностью " << eps << ": " << root << "\n";
        cout << "f(root) = " << f(root) << "\n";
        return;
    }

    cout << "Не найдено регионов с требуемым изменением знака f(A) < 0 и f(B) > 0\n";
}

int main()
{
    setlocale(LC_ALL,"Russian");
    Solve();
}
